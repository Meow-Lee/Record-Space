- - - 
# 개념
- 하나의 어플리케이션을 다수의 독립적인 서비스들의 집합으로 구성하는 것
- 각자 별도의 프로세스에서 실행되며 HTTP API같은 가벼운 매커니즘으로 통신하는 작은 애플리케이션
- 작은 서비스들은 각자의 비즈니스 기능을 담당하고 완전 자동화 된 절차에 따라 독립적으로 배포됨
- 각 서비스는 서로 다른 프로그래밍 언어나 서로 다른 데이터 저장 기술을 사용할 수 있음
- Monolithic 시스템에서 발생되는 문제들을 해결

# Monolithic System
- 전체 기능을 단일 코드베이스로 개발
- 대규모 단일 코드 베이스를 빌드/배포
- 단일 통합 데이터베이스 사용

### 장점
- 상대적으로 운영하기 용이
	- 코드 관리, 장애 관리, 로그 관리, 모니터링
- 내부 메소드 호출로 성능 문제 없음
	- MSA는 Network 통한 Interface 호출
- 트랜잭션 관리 용이

### 단점
- 스케일 아웃 시 전체 시스템을 확장해야 하는 비효율
- 빌드/배포 시간 오래 걸림
- 작은 수정에도 전체 시스템 빌드/배포해야 함
- 하나의 버그에 전체 시스템이 실패할 수 있음
- 기능 간의 결합도가 일반적으로 높음
	- 다른 기능의 테이블 직접 접근하기도
- 기능 변경 시 영향도 파악 어려움
	- 코드 의존 관계
	- 데이터 의존 관계
- 결과적으로 코드가 운영환경에 민첩하게 배포되기 어려움

# Monolithic System 종류
### Single Monolithic System
- 가장 일반적인 형태
-  코드 베이스에서 각 기능들이 쪼개기 힘들정도로 뭉쳐있는 형태
### Modular Monolith System
- 각 기능별로 모듈화 되어 있는 형태
-  MSA의 좋은 대안이 될 수 있음
- Monolith의 가장 큰 문제
	- 기능 간 결합도
	- 코드 수정 시 영향도
- 결합도를 잘 다루면 유지보수성 높은 SW 가능
- 베포와 확장에 대한 이슈는 여전히 존재

### Distributed Monolithic System
- 분산된 Monolith
- MSA는 아님
- 쪼개진 서비스 간에 매우 강결합 된 형태
- 항상 같이 배포되는 형태
- Monolith의 단점 모두 존재
	- 영향도
	- 결합도
- 분산 시스템의 단점도 존재
	- 네트워크를 통한 협력에 의한 성능 저하
	- 관리 어려움

# MicroServices 장단점
- 작은 서비스 단위로 확장 가능
- 일부의 장애가 시스템 전체 장애로 이어지지 않음
- 서비스 단위로 자율적 배포 가능
- 결과적으로 빠르게 변화하는 비즈니스 환경에 민첩하게 대응 가능
### 장점
- **빠른 Delivery**
	- 각 서비스는 독립적으로 개발되고 느슨하게 결합
	- 서비스는 작기 때문에 코드 수정에 대한 영향 범위가 상대적으로 작음
		- 빠른 영향도 파악, 빠른 빌드, 빠른 테스트
	- 각 서비스들은 네트워클르 통한 Interface로 느슨한 결합 됨
		- 서비스 간 자율적인 배포 가능
- **탄력적이고 선택적인 확장**
	- 작은 서비스 단위로 확장 가능
	- Monolith는 전체 Scale Out 필요 -> 비효율
	- 각 서비스는 코드베이스가 작아 확장 비용이 상대적으로 저렴
- **Polyglot Architecture 지원**
	- 특정 Task에 가장 적절한 기술을 적용 가능
	- 각 서비스는 자신만의 고유한 언어/Framework 선택 가능
- **실험과 혁신 가능**
	- Monolith 환경 에서는 단순한 기술 실험도 어려움
		- 영향도와 비용의 문제
		- DB/Framework 변경은 물론 언어의 버전 업도 어려운 작업
	- 마이크로서비스는 새로운 기술들을 쉽게 실험해 볼 수 있음
		- 작은 코드 베이스
		- 서비스 간 느슨한 결합
- **대체 가능성**
	- 언어/프레임워크를 완전히 새롭게 개발 가능
	- 각 서비스는 작고 서비스 간에 느슨하게 연결되어 있기 때문
	- 적절한 서비스의 크기
- **기술 부채 경감**
	- SW는 관리하지 않으면 기술 부채 쌓임
	- Monolith는 강한 결합도 때문에 코드 수정 어려움
	- 서비스 크기가 작아 품질 관리에 용이
	- 품질 향상을 위한 코드 개선 시 영향도 작음
### 단점
- 컴퓨팅 자원의 사용이 Monolith보다 비효율적
- 성능
	- 내부 호출보다 느림
- 메모리
	- JVM 등 중복적인 자원 사용
- 운영 관리가 어려움
- 모니터링 대상 증가
- 다양한 장애 상황 발생
- 배포 대상 서비스 증가 및 기술의 다변화
- 단위 테스트 컴포넌트 테스트 난이도 증가
- DB 트랜잭션 처리 어려움
- 서비스 간 Polyglot Data Store 사용
- 분산 환경에서 트랜잭션 어려움

# MSA 특징
### 서비스를 통한 컴포넌트화
- 서비스 단위를 컴포넌트로 정의
	- 특정 비즈니스 기능을 담당
	- 독립적인 프로세스로 실행
	- 자율적으로 배포 가능
- 서비스는 응집도 높게 설계되어야 함
- 서비스 간에는 명확한 인터페이스 사용
### 비즈니스 역량에 따른 조직 구성
- Conway의 법칙
	- 시스템을 설계하는 조직은 그 조직의 소통 구조를 닮은 아키텍처를 만듬
- 단일 비즈니스 영역 기능의 변경이 다수의 팀 간의 협업을 필요로 함
### 프로젝트보다 제품에 집중
- 기존에는 개발과 운영이 분리되어 있음
- 팀이 개발/운영을 포함한 전체 라이프사이클을 책임
### 똑똑한 End Point, 단순한 Pipe
- 도메인 로직은 각 서비스 내에 응집도 높게 유지
- 각 서비스 간 연결은 HTTP API, MQ 등을 사용해 느슨하게 유지
### 분산된 거버넌스
- 중앙에 강력한 표준이나 절차의 준수를 강요하지 않음
- 스스로 효율적인 방법론과 도구, 기술을 찾아 적용
### 분산된 데이터 관리
- 해당 서비스의 데이터를 각자 관리
- 서비스는 서로 다른 데이터 저장 기술을 사용 가능
- 각 서비스는 API를 통해서만 다른 서비스의 데이터에 접근
- 트랜잭션 처리 어려움, 결과적 일관성의 적용
### 장애 방지 설계
- 특정 서비스의 장애는 항상 일어나고 다른 서비스로 전파됨
- 일부 서비스 장애가 전체 시스템 장애로 전파되는 것을 막는 것이 핵심

# MSA 도입 조건
## 사업/조직적 측면
- MSA가 중장기적 Business Benefit을 올릴 수 있다는 합의가 전제
- 단순 기술 도입이 아닌 조직과 프로세스의 개선 작업 필요
	- 비즈니스 역량에 기반한 조직 구성
	- 조직의 구성이 아키텍처에 반영됨
- DevOps 문화 정착
## 기술적 측면
- Rapid Provisioning
	- 클라우드 환경
	- 인프라 자동화, Docker/Kubernetes
- 정교한 Monitoring 및 장애관리
- 자동화된 배포
# 마이크로 서비스 역량 모델
### 핵심 역량
- 단일 서비스 내에 패키징 되는 SW 컴포넌트들
	- 서비스 Listener
		- HTTP 등의 Listener가 애플리케이션에 내장되어 있어야 함
			- WS, WAS
			- Spring Boot와 같은 Self Contained 방식 필요
		- MSA의 민첩한 배포, 운영의 장점을 살리기 위해선 자체 내장형 Listener 필요
	- Endpoint
		- HTTP 요청을 받아 처리할 API가 애플리케이션 내부에 있어야 함
		- 다양한 프로토콜 사용 가능
		- 동기/비동기 방식 모두 사용 가능
	- 서비스의 구현
		- 각 서비스의 핵심 로직 구현
		- 서비스의 로직은 단일 책임의 원칙을 지켜야 함
		- 서비스 로직은 최대한 응집도 높게 구현되어야 함
		- 계층형 아키텍처를 사용하는 것이 좋음
		- Hexagonal Architecture
			- Application을 외부 기술과 분리시키는 패턴
			- 비즈니스 핵심 로직이 외부 시스템에 영향을 받지 말아야 함
	- 데이터 저장
		- 각 서비스마다 상태나 데이터를 저장할 데이터소스가 있어야함
		- 하나의 서비스에 한정되야함
		- 다양한 기술 이용 가능
### InfraStructure 역량
- 클라우드
	- On Demand
	- 대용량 확장 가능한 환경
- 몇 번의 클릭만으로 리소스 사용 가능
	- Auto Scaling으로 자동화 된 Provisioning
- 다양한 자원/서비스 제공
	- 컴퓨팅 자원, DB, NoSQL, Big Data, AI
- 컨테이너 런타임 - 인프라 역량
	- 각 서비스들이 다양한 기술 사용
	- 수백 수천개의 인스턴스에 배포해야함
	- 컨테이너 기술을 이용하여 빠른 환경 구성 및 배포 필요
- 컨테이너 오케스트레이션 - 인프라 역량
	- 많은 수의 컨테이너의 관리 역량 필요
	- 배포, 모니터링 등 운영 관리 비용을 최소화하기 위함
	- Kubernetes, ECS, Mesos/Marathon
### 지원 역량
- Service Discovery
	- MSA를 도입하면 서비스 개수 및 인스턴스 개수가 급증 가능
	- 전체 Topology가 복잡해짐
	- 한 서비스에서 다른 서비스 호출 시 물리적인 정보를 유지하는 것이 비효율적
	- 중앙에서 시스템의 모든 서비스에 대한 정보를 유지
	- 새로운 인스턴스가 생성되면 중앙 에이전트에게 자신의 정보를 등록
	- 서비스 간에는 다른 서비스의 물리적인 주소를 유지하지 않음
	- 유연하게 인스턴스 및 서비스를 추가 삭제 가능
- Config Server
	- 기존에는 설정 정보를 자체 설정 파일이나 OS 환경 변수로 관리
	- 설정 관리가 복잡하고 환경마다 매번 새롭게 빌드/패키징을 해야되는 문제
	- 설정 정보를 Application 파일에서 완전히 분리
	- 중앙 Config Server에서 설정 관리, 저장 Backend로는 Git, DBMS 사용
	- 서비스는 Application 기동될 때 중앙 서버에서 Config 정보 Fetch
	- 설정 정보 변경 시 서비스 재배포 없이 반영 가능
- Service Gateway
	- 다양한 서비스들에 대한 단일 진입점
	- 인증, 인가, 로깅, 필터링 등의 공통 처리 수행
	- 요청을 뒷단에 있는 서비스에 라우팅해주는 역할
- SW Defined Load Balancer
	- 서비스를 호출하는 클라이언트에서 SW로 Load Balancing 수행
	- Service Registry를 사용해서 Service A가 Service B를 호출할 때 A에 붙어있는 Load Balancer가 인스턴스 정보를 받아 밸런싱을 수행
- Circuit Breaker(회로차단기)
	- 서비스의 장애에 대한 패턴
	- 하나의 서비스 장애가 다른 서비스들에 전파되어 결국 전체 시스템 장애로 이어질 수 있음
	- 특정 서비스 장애는 그 서비스만의 장애로 격리해야 함
	- 서비스 간의 Circuit Breaker 컴포넌트가 삽입됨
	- 특정 서비스의 장애가 발생했다고 판단되면 Circuit 차단
- Distributed Tracing(분산 추적)
	- 하나의 API 호출이 다양한 서비스에 분산되므로 에러 추적이 어려움
	- 서비스 간 모든 호출에 추적 ID를 삽입
	- 추적 ID를 Key로 하여 단일 API 트랜잭션의 활동을 파악
- Data Lake
	- MSA에서는 데이터 파편화 가능성 존재
	- 비정형 원시 데이터를 그대로 저장
		- 처리기술 발달, Hadoop, HDFS
	- 데이터를 분석할 시점에 데이터 가공에 대해 고민
	- 실시간 Data Ingestion 도구 사용
		- Flume, Kafka, Logstash
- Messaging
	- 메시징을 이용한 서비스 간 협력 설계 방식을 권고
	- 메시징(이벤트) 주도 설계는 서비스 간 결합도를 낮출 수 있음
	- 고가용성의 메시징 솔루션이 필요
	- RabbitMQ, ActiveMQ, Kafka, AWS Kinesis
- DevOps
	- 에자일과 DevOps는 MSA 성공을 위한 필수 요소 중 하나
	- 한 팀에서 개발, 배포, 운영, 모니터링이 되어야 함

# 서비스 분리 전략
- 기본 Monolith를 Microservice로 분리하기 위한 전략

### 3 Key Point
- 단계적으로 마이그레이션
- 처음에는 크게 분리하고 추후에 작게 분리
- 서비스 분리의 공식은 없음

### 작고 분리가 쉬운 서비스로 워밍업
- 작은 Pilot 서비스 선택
	- 신규 개발되는 작은 기능
	- 기존 Monolith에서 분리 가능한 작은 기능
- 신규 서비스 -> 기존 Monolith로의 의존성이 없거나 적은 서비스
	- 독립적으로 개발/배포 될 수 있는 것이 좋음
### 핵심 기능의 분리
- 다른 기능들과의 결합도 높음
- 도메인 경계가 명확하지 않을 가능성 높음
	- 장기간의 유지보수
	- 개발자의 변경
	- 요구사항의 변화
- 비즈니스 팀 구조를 기반으로 분리
- 도메인 주도 설계 적용
### 분리 대상 선정
- 조직의 목표를 명확하게 수립하는 것
- 자주 코드 수정해서 Production 환경에 배포 후 실험을 해야 함

# 결합도, 응집도, SRP
### 결합도
- 특정 기능을 수정하는데 같이 수정되어야 하는 다른 기능이 얼마나 되는가
### 응집도
- 유사한 기능끼리 얼마나 잘 그룹화되어 있는가
### SRP, 단일 책임의 원칙
- 객체지향 프로그래밍의 원칙으로 사용됨
- 객체는 변경에 대한 이유가 단 한가지어야 함
- 서비스는 변경에 대한 이유가 하나의 비즈니스 영역 때문이어야 함
	- 결제 서비스가 변경되어야 하는 이유는 결제팀의 요구사항 변경 때문이어야 함
### Microservice Bad Smell
- 단일 비즈니스 영역의 요구사항 변경에 대해 다수의 서비스가 배포되어야 함
- 서로 다른 비즈니스 영역의 요구사항 변경에 대해 특정 서비스가 자주 배포되어야 함