- - -
# Container
### 문제
- Application을 다른 서버에 배포했더니 동작이 다름
- 같은 미들웨어를 10대를 설치했는데 1-2대의 서버에서만 이상 동작을 함
- 서버 OS, 라이브러리 등의 버전을 완전히 맞추기가 어려움
- 인프라의 가변성이 근본적인 문제
- Application이 의존하고 있는, Application을 둘러 싸고 있는 환경의 차이를 없애는 것이 중요
### 정의
- 외부 환경으로부터 격리된 프로세스
- Application을 표준화 된 단위로 패키징하여 동일한 방법으로 배포하기 위한 기술
- Application Code 뿐만 아니라 외부 환경을 하나로 패키징
	- Runtime, Libraries, Configurations ...
- 격리된 공간에서 프로세스가 동작하는 기술
- 가상화 기술의 하나지만 기존 방식과는 차이가 있음

# Docker
- 컨테이너 기반의 오픈소스 가상화 플랫폼
- 프로그램 배포 및 관리를 단순하게 해 줌
- 다양한 프로그램, 실행 환경을 컨테이너로 추상화하고 동일한 인터페이스를 제공
### 특징
- 높은 확장성
- 쉽고 빠르게 서버 환경 구축 가능
- Docker만 설치되어 있으면 컨테이너 사용 가능
- 표준화 가능
- Java, Python, Nodejs 등 서로 다른 App들을 동일한 방식으로 실행 가능
- 이종 기술이라도 배포 및 운영 과정이 동일함
- 재현 가능한 이미지
- 기존의 가상 머신 이미지는 재현 어려움
	- Docker 이미지는 Dockerfile이라는 파일에 이미지가 어떻게 만들어지는지 기술
		- 100% 재현 가능
### 이미지
- 컨테이너 실행에 필요한 파일과 설정 값 등을 포함하고 있는 것
- 컨테이너는 이미지를 실행한 상태
- 같은 이미지에서 여러 개의 컨테이너를 생성
- 도커 이미지는 Docker hub에 등록하거나 Docker Registry 저장소에 저장
### 이미지와 컨테이너
- Image는 실행할 애플리케이션 및 미들웨어의 정보를 담는 스냅샷
- Container는 Image를 실행시킨 인스턴스
- 하나의 Image로 다수의 Container 실행 가능
- 이미지는 컨테이너를 실행하기 위한 모든 정보를 가지고 있음
- 의존성 파일을 컴파일하고 애플리케이션을 설치할 필요가 없음
- 새로운 서버가 추가되면 미리 만들어 놓은 이미지를 다운받고 컨테이너를 생성만 하면 됨
- 한 서버에 여러 개의 컨테이너를 실행할 수 있고 수천대의 서버도 동일하게 생성 가능
### 장점
- 변화하지 않는 실행환경으로 Idempotency 확보
- 코드를 통한 실행 환경 구축 및 애플리케이션 구성
- 실행 환경과 애플리케이션의 일체화로 이식성 향상
- 시스템을 구성하는 애플리케이션 및 미들웨어의 관리 용이성 증가

# Container Orchestration을 위한 Kubernetes
- 소수의 컨테이너는 수동으로 관리 가능
- 다수의 멀티 호스트로 구성된 대용량 분산 환경에서는 수동 작업 불가
- 다수의 컨테이너를 쉽게/자동으로 관리할 수 있는 역량 필요
- 다수의 호스트(서버)를 하나의 클러스터처럼 사용
- 여러 개의 호스트(서버)에 컨테이너 배포
- 서비스 디스커버리로 서비스들을 연결
- 부하가 생기면 서버를 자동으로 Scale-out
- 장애 발생하면 기존 컨테이너 kill 후 새로운 컨테이너 다시 생성
- 컨테이너 Health Check
- 컨테이너 간 Storage 및 Network 관리
# Kubernetes
- 컨테이너 오케스트레이션 도구
- 분산 환경에서 대규모의 컨테이너들에 대한 관리
- 사실상 컨테이너 오케스트레이션의 표준
### 특징
- 대규모 분산환경에서 상대적으로 소수의 엔지니어만으로 컨테이너를 관리하는 것이 목적
- 멀티 호스트에서 컨테이너 관리
- 컨테이너 배포, 감시, 업데이트
- 컨테이너 간 네트워크 관리
- 장애 발생 시 자동 복구
# Docker Swarm
- 설치와 사용이 K8s에 비해 단순하다는 장점
- 대용량 분산환경에서 사용하기엔 기능이 부족
	- 모니터링, 스토리지 옵션 등

# Kubernetes 구조와 Objects 소개
## K8s의 구조
- Master에 API서버와 상태 저장소를 두고
- 각 서버(node)의 에이전트(kubelet)와 통신하는 구조
### 마스터
- K8s 클러스터 관리 역할
- 노드의 상황 파악
- 컨테이너를 어떤 노드에서 가동할지 선택
### API 서버
- 모든 요청을 처리하는 마스터의 핵심
- 인증 및 인가 기능 보유
- 모든 컴포넌트들은 API 서버를 통해서 커뮤니케이션
### 스케줄러
- 컨테이너를 어떤 노드에서 가동할지 결정하는 컴포넌트
- 노드들의 정보를 파악하고 컨테이너를 가동할 적합한 노드 선택
### 컨트롤러 매니저
- K8s 클러스터의 상태를 감시
- 실제 요청된 상태와 현재 시스템 상태에 차이가 있는지 실시간 감시
- 다른 경우 같아지도록 조치
### 분산 데이터 저장소 etcd
- 분산 key-value 저장소
- 클러스터의 모든 설정, 상태 데이터 저장
- 마스터에서 분리하여 독자적으로 구축 가능
### 노드
- 컨테이너가 가동되는 서버
- 다수의 노드로 클러스터를 구성
- 클라우드의 경우 가상머신이 노드가 됨
	- ec2 등
### kubelet
- 실제로 컨테이너를 생성하는 주체
### kube proxy
- 각 노드에서 실행되는 네트워크 프록시
- 노드의 네트워크 규칙을 유지 관리

# K8s Object
- 대규모 분산 환경에 필요한 요소들이 추상화 되어 있음
- 컨테이너, 애플리케이션 수행 방식, 네트워크 등을 추상화
- 이렇게 추상화 한 것들을 Object라 통칭
### Pod
- K8s에서 배포할 수 있는 가장 작은 단위
- 한 개 이상의 컨테이너와 스토리지, 네트워크 속성을 가짐
- 컨테이너를 하나만 사용하는 경우도 반드시 Pod로 관리
### ReplicaSet
- Pod을 여러 개 복제하여 관리
- 한 개 이상 생성하고 개수를 유지하려면 ReplicaSet 사용
### Deployment
- K8s에서 실제 배포를 진행하는 기본 단위
- 배포 전략 선택
- 배포 Revision 관리 및 Roll Back
### DaemonSet
- 클러스터 전체에 Pod를 띄울 때 사용하는 Controller
- 항상 모든 Node에 특정 Pod가 실행됨
- 새로운 Node가 추가되면 자동으로 Pod 실행됨
- 로그 수집기나 모니터링 에이전트 등 실행하는 용도
### StatefulSet
- K8s의 대부분 Controller는 Stateless
- 상태를 유지하는 Pod을 위한 Object
- Volume을 사용해서 데이터를 저장하고 Pod 재기동 시에도 유지 가능
- DB 등을 컨테이너화 할 때 사용 가능
### Service
- 네트워크와 관련된 Object
- Pod 간 연결 및 Pod와 외부 네트워크를 연결
- 여러 개의 Pod에 대한 내부 로드밸런서
- 내부 DNS에 서비스 등록하여 서비스 디스커버리 역할도 함
### Ingress
- 외부 트래픽을 받는 Object
- 라우팅 규칙, 로드밸런싱 규칙 등도 포함
- K8s 클러스터를 외부로 노출할 때는 일반적으로 Ingress 사용
### Manifest 파일
- K8s에서 선언적 설정을 위해 사용
- YAML 파일로 작성
- 리소스의 종류와 원하는 상태를 입력
- 식당 주문서와 유사